防抖函数
debounce(func, delay) {
  let timer = null;
  return function(...args) {
    if(timer) {
      clearTimeout(timer)
    };
    timer = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}

节流函数
throttle(func, delay) {
  let timer = null;
  return function(...args) {
    if(!timer){
      timer = setTimeout(() =>{
        func.apply(this, args);
        timer = null;
      }, delay)
    }
  }
}

new 的实现
//new的过程
//1、创建一个空的对象
//2、空的对象的原型链接到构造函数的原型
//3、绑定this到新创建的对象 ,添加属性到新的对象上，
// 保存方法的执行结果     (一般new出来的对象的this是指向实例，所以new的实现需要绑定this)
//4、返回该对象
PS：如果构造函数返回值类型，对new对象无影响；如果返回引用类型（数组，函数，对象），则实例化对象就是
该返回的引用类型。

function newF(fn, ...args) {
  var obj = new Object();
  obj._proto_ = fn.prototype;
  var result = fn.apply(obj, args);
  return result instanceOf Object || result instanceOf Function ? result : obj;
}
使用Object.create简化写法：
function newF(fn, ...args) {
  var obj = Object.create(fn.prototype)
  var result = fn.apply(obj, args);
  return result instanceOf Object || result instanceOf Function ? result : obj;
}

call的实现