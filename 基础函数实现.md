防抖函数
debounce(func, delay) {
  let timer = null;
  return function(...args) {
    if(timer) {
      clearTimeout(timer)
    };
    timer = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}

节流函数
throttle(func, delay) {
  let timer = null;
  return function(...args) {
    if(!timer){
      timer = setTimeout(() =>{
        func.apply(this, args);
        timer = null;
      }, delay)
    }
  }
}

new 的实现
//new的过程
//1、创建一个空的对象
//2、空的对象的原型链接到构造函数的原型
//3、绑定this到新创建的对象 ,添加属性到新的对象上，
// 保存方法的执行结果     (一般new出来的对象的this是指向实例，所以new的实现需要绑定this)
//4、返回该对象
PS：如果构造函数返回值类型，对new对象无影响；如果返回引用类型（数组，函数，对象），则实例化对象就是
该返回的引用类型。

function newF(fn, ...args) {
  var obj = new Object();
  obj._proto_ = fn.prototype;
  var result = fn.apply(obj, args);
  return typeof result =='object' || result instanceof Function ? result : obj;
}
//使用Object.create简化写法：
function newF(fn, ...args) {
  var obj = Object.create(fn.prototype)
  var result = fn.apply(obj, args);
  return typeof result =='object' || result instanceof Function ? result : obj;
}

call的实现    
              fn.myCall(obj, args)
Function.prototype.myCall = function(target, ...ars) {
  //这里this指向调用该方法的函数
  if(typeof this !== 'function') {
    throw new TypeError('not a function')
  }
  target = target || window
  target.fn = this    //隐示绑定，改变this的指向，从fn到obj
  let reslt = target.fn(args)
  return result
}

apply的实现
//apply和call的区别，apply的参数传递需要数组形式，call是单个传递
Function.prototype.myApply = function(target, ...args) {
  if(typeof this !== 'function') {
    throw new TypeError('not a function')
  }
  if(!Array.isArray(args) {                       //可能还要判断一下是否类数组
    throw new Error('arg not a array)
  }
  target = target || window
  target.fn = this
  let result = target.fn(args)
  return result
}

bind的实现
//bind与apply，call不同在fn.bind(obj)不会立即执行。且bind返回的新函数可以普通调用，也可以构造函数调用
    作为构造函数时，this指向实例。同时bind()方法的参数还有函数柯里化的特性。即保留一个参数的位置，第
    二次传参会自动把参数存入这个位置。

Function.prototype.myBind = function(thisArg) {
  if(typeof this !== 'function') {
    throw new TypeError('Bind must be called on a function')
  }
  const args = Array.prototype.slice.call(arguments, 1),
  selt = this,
  nop = function() {},
  bound = function() {
    return self.apply(
      this instanceof nop ? this : thisArg,
      args.concat(Array.prototype.slice.call(arguments))
    );
  };
  if(this.prototype) {
    nop.prototype = this.prototype;
  }
  bound.prototype = new nop();
  return bound
}